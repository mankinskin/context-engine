// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { EdgeRef } from "./EdgeRef";
import type { PathNode } from "./PathNode";

/**
 * Transition describing how the search path changed at this step.
 *
 * The search path models an `IndexRangePath = (start_path, root, end_path)`:
 *
 * - **start_path** grows upward (parent exploration): each `PushParent`
 *   appends a `ChildLocation` linking current root â†’ parent.
 * - **root** is set when the first child match converts a parent candidate
 *   into a `CompareState`.
 * - **end_path** grows downward (child comparison / prefix decomposition):
 *   each `PushChild` appends a `ChildLocation` for child-ward descent.
 *
 * Reconstruction: apply transitions in order to build the path graph.
 */
export type PathTransition = { "kind": "set_start_node", node: PathNode, } | { "kind": "push_parent", 
/**
 * The parent vertex we moved up to.
 */
parent: PathNode, 
/**
 * Edge from previous top-of-start-path to this parent.
 */
edge: EdgeRef, } | { "kind": "set_root", 
/**
 * The root vertex.
 */
root: PathNode, 
/**
 * Edge from the last start_path node into the root
 * (the root is a parent of the start-path top, containing
 * the first matched child pattern).
 */
edge: EdgeRef, } | { "kind": "push_child", 
/**
 * The child vertex we descended into.
 */
child: PathNode, 
/**
 * Edge from current end_path bottom to this child.
 */
edge: EdgeRef, } | { "kind": "pop_child" } | { "kind": "replace_child", 
/**
 * The new child vertex.
 */
child: PathNode, 
/**
 * Edge from parent to new child.
 */
edge: EdgeRef, } | { "kind": "child_match", 
/**
 * Atom position in the query after match.
 */
cursor_pos: number, } | { "kind": "child_mismatch", 
/**
 * Atom position where mismatch was detected.
 */
cursor_pos: number, } | { "kind": "done", 
/**
 * Whether the search found a match.
 */
success: boolean, };
