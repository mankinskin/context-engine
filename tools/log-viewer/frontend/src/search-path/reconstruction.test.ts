/**
 * Cross-language tests for search path reconstruction.
 *
 * Test fixtures are generated by the Rust test
 * `context-trace::graph::search_path::tests::generate_cross_language_fixtures`.
 *
 * Run `cargo test -p context-trace generate_cross_language_fixtures` to
 * regenerate whenever search_path.rs types change.
 */

import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { resolve } from 'path';

import type { PathTransition, VizPathGraph } from '../types/generated';
import { fromTransitions } from './reconstruction';

interface TestFixture {
  name: string;
  transitions: PathTransition[];
  expected: VizPathGraph;
}

// Load fixtures generated by Rust
const fixturesPath = resolve(__dirname, 'test-fixtures.json');
const fixtures: TestFixture[] = JSON.parse(
  readFileSync(fixturesPath, 'utf-8'),
);

describe('search path reconstruction (cross-language)', () => {
  it('should have loaded at least one fixture', () => {
    expect(fixtures.length).toBeGreaterThan(0);
  });

  for (const fixture of fixtures) {
    it(`reconstructs "${fixture.name}" identically to Rust`, () => {
      const result = fromTransitions(fixture.transitions);
      expect(result).toEqual(fixture.expected);
    });
  }
});

describe('search path reconstruction edge cases', () => {
  it('empty transitions produce empty graph', () => {
    const result = fromTransitions([]);
    expect(result.start_node).toBeNull();
    expect(result.root).toBeNull();
    expect(result.done).toBe(false);
  });

  it('throws on PushParent before SetStartNode', () => {
    expect(() =>
      fromTransitions([
        {
          kind: 'push_parent',
          parent: { index: 1, width: 1 },
          edge: { from: 1, to: 0, pattern_idx: 0, sub_index: 0 },
        },
      ]),
    ).toThrow(/SetStartNode/);
  });

  it('throws on SetStartNode called twice', () => {
    expect(() =>
      fromTransitions([
        { kind: 'set_start_node', node: { index: 1, width: 1 } },
        { kind: 'set_start_node', node: { index: 2, width: 1 } },
      ]),
    ).toThrow(/twice/);
  });

  it('throws on PushChild before SetRoot', () => {
    expect(() =>
      fromTransitions([
        { kind: 'set_start_node', node: { index: 1, width: 1 } },
        {
          kind: 'push_child',
          child: { index: 3, width: 1 },
          edge: { from: 1, to: 3, pattern_idx: 0, sub_index: 0 },
        },
      ]),
    ).toThrow(/SetRoot/);
  });

  it('throws on PopChild on empty end_path', () => {
    expect(() =>
      fromTransitions([
        { kind: 'set_start_node', node: { index: 1, width: 1 } },
        {
          kind: 'set_root',
          root: { index: 10, width: 2 },
          edge: { from: 10, to: 1, pattern_idx: 0, sub_index: 0 },
        },
        { kind: 'pop_child' },
      ]),
    ).toThrow(/empty/);
  });

  it('throws on ReplaceChild on empty end_path', () => {
    expect(() =>
      fromTransitions([
        { kind: 'set_start_node', node: { index: 1, width: 1 } },
        {
          kind: 'set_root',
          root: { index: 10, width: 2 },
          edge: { from: 10, to: 1, pattern_idx: 0, sub_index: 0 },
        },
        {
          kind: 'replace_child',
          child: { index: 5, width: 1 },
          edge: { from: 10, to: 5, pattern_idx: 0, sub_index: 1 },
        },
      ]),
    ).toThrow(/empty/);
  });
});
