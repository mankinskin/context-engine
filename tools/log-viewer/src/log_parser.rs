//! Log file parser for tracing JSON output
//!
//! Parses pretty-printed JSON logs generated by context-trace's tracing_utils.
//! Each JSON object may span multiple lines with indentation.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A parsed log entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    /// Entry index (1-based)
    pub line_number: usize,
    /// Log level (TRACE, DEBUG, INFO, WARN, ERROR)
    pub level: String,
    /// Timestamp string
    pub timestamp: Option<String>,
    /// The log message
    pub message: String,
    /// Event type (event, span_enter, span_exit, span_new, span_close)
    pub event_type: String,
    /// Span name (if this is a span event)
    pub span_name: Option<String>,
    /// Indentation depth (number of parent spans)
    pub depth: usize,
    /// Additional fields (preserves structured JSON values)
    pub fields: HashMap<String, serde_json::Value>,
    /// Source file location
    pub file: Option<String>,
    /// Source line number
    pub source_line: Option<u32>,
    /// Stack trace (for panics)
    pub backtrace: Option<String>,
    /// Raw JSON content (pretty-printed)
    pub raw: String,
}

/// Raw JSON structure from tracing-subscriber
#[derive(Debug, Deserialize)]
struct TracingJson {
    timestamp: Option<String>,
    level: Option<String>,
    fields: Option<serde_json::Value>,
    target: Option<String>,
    span: Option<SpanInfo>,
    spans: Option<Vec<SpanInfo>>,
    #[serde(rename = "filename")]
    file: Option<String>,
    #[serde(rename = "line_number")]
    line: Option<u32>,
}

#[derive(Debug, Deserialize)]
struct SpanInfo {
    name: Option<String>,
    #[serde(flatten)]
    fields: HashMap<String, serde_json::Value>,
}

/// Parser for log files
pub struct LogParser;

impl LogParser {
    pub fn new() -> Self {
        Self
    }

    /// Parse log content into structured entries
    /// 
    /// Handles both pretty-printed JSON (multi-line) and NDJSON formats.
    /// Uses serde_json's streaming deserializer to parse consecutive JSON objects.
    pub fn parse(&self, content: &str) -> Vec<LogEntry> {
        let mut entries = Vec::new();
        
        // Use streaming deserializer to handle multiple JSON objects
        let stream = serde_json::Deserializer::from_str(content).into_iter::<TracingJson>();
        
        for (index, result) in stream.enumerate() {
            let entry_num = index + 1;
            
            match result {
                Ok(json) => {
                    // For pretty JSON, we don't have exact line info, so use entry index
                    entries.push(self.json_to_entry(entry_num, &json));
                }
                Err(e) => {
                    // Log parse error as a fallback entry
                    entries.push(LogEntry {
                        line_number: entry_num,
                        level: "ERROR".to_string(),
                        timestamp: None,
                        message: format!("JSON parse error: {}", e),
                        event_type: "error".to_string(),
                        span_name: None,
                        depth: 0,
                        fields: HashMap::new(),
                        file: None,
                        source_line: None,
                        backtrace: None,
                        raw: format!("Parse error at entry {}", entry_num),
                    });
                    // Stop on parse errors to avoid cascading failures
                    break;
                }
            }
        }
        
        entries
    }

    fn json_to_entry(&self, line_number: usize, json: &TracingJson) -> LogEntry {
        let level = json.level.clone().unwrap_or_else(|| "INFO".to_string());
        
        // Extract message and event type from fields
        let (message, event_type, backtrace) = self.extract_message_and_type(&json);
        
        // Extract span name
        let span_name = json.span.as_ref()
            .and_then(|s| s.name.clone())
            .or_else(|| {
                json.spans.as_ref()
                    .and_then(|spans| spans.last())
                    .and_then(|s| s.name.clone())
            });
        
        // Calculate depth from spans array
        let depth = json.spans.as_ref().map(|s| s.len()).unwrap_or(0);
        
        // Extract additional fields - preserve JSON structure for typed values
        let mut fields: HashMap<String, serde_json::Value> = HashMap::new();
        if let Some(field_value) = &json.fields {
            if let Some(obj) = field_value.as_object() {
                for (key, value) in obj {
                    // Skip the message field, we handle it separately
                    if key != "message" && key != "backtrace" {
                        fields.insert(key.clone(), value.clone());
                    }
                }
            }
        }
        
        // Also extract fields from current span
        if let Some(span) = &json.span {
            for (key, value) in &span.fields {
                if key != "name" {
                    fields.insert(key.clone(), value.clone());
                }
            }
        }
        
        LogEntry {
            line_number,
            level: level.clone(),
            timestamp: json.timestamp.clone(),
            message: message.clone(),
            event_type,
            span_name,
            depth,
            fields,
            file: json.file.clone(),
            source_line: json.line,
            backtrace,
            // Generate a compact summary for raw field
            raw: format!("[{}] {}", level, message),
        }
    }

    fn extract_message_and_type(&self, json: &TracingJson) -> (String, String, Option<String>) {
        let mut message = String::new();
        let mut event_type = "event".to_string();
        let mut backtrace = None;
        
        if let Some(fields) = &json.fields {
            if let Some(obj) = fields.as_object() {
                // Check for message field
                if let Some(msg) = obj.get("message") {
                    message = match msg {
                        serde_json::Value::String(s) => s.clone(),
                        other => other.to_string(),
                    };
                }
                
                // Check for backtrace field
                if let Some(bt) = obj.get("backtrace") {
                    backtrace = match bt {
                        serde_json::Value::String(s) => Some(s.clone()),
                        other => Some(other.to_string()),
                    };
                }
            }
        }
        
        // Detect span events from message content
        if message.contains("new") || message.contains("enter") {
            // Check if this is a span enter/new event
            if let Some(span) = &json.span {
                if span.name.is_some() {
                    if message.contains("new") {
                        event_type = "span_new".to_string();
                    } else {
                        event_type = "span_enter".to_string();
                    }
                }
            }
        } else if message.contains("close") || message.contains("exit") {
            if json.span.is_some() {
                if message.contains("close") {
                    event_type = "span_exit".to_string();
                } else {
                    event_type = "span_exit".to_string();
                }
            }
        }
        
        // If message is empty, use target or generate a description
        if message.is_empty() {
            if let Some(span) = &json.span {
                if let Some(name) = &span.name {
                    message = format!("Span: {}", name);
                    event_type = "span_enter".to_string();
                }
            }
            if message.is_empty() {
                message = json.target.clone().unwrap_or_else(|| "Unknown".to_string());
            }
        }
        
        (message, event_type, backtrace)
    }
}

impl Default for LogParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_event() {
        let parser = LogParser::new();
        let content = r#"{"timestamp":"2024-01-01T00:00:00.000000Z","level":"DEBUG","fields":{"message":"Processing token"},"target":"test","filename":"src/main.rs","line_number":42}"#;
        let entries = parser.parse(content);
        
        assert_eq!(entries.len(), 1);
        let entry = &entries[0];
        assert_eq!(entry.level, "DEBUG");
        assert_eq!(entry.event_type, "event");
        assert_eq!(entry.message, "Processing token");
        assert_eq!(entry.file.as_deref(), Some("src/main.rs"));
        assert_eq!(entry.source_line, Some(42));
    }

    #[test]
    fn test_parse_span_enter() {
        let parser = LogParser::new();
        let content = r#"{"timestamp":"2024-01-01T00:00:00.000000Z","level":"INFO","fields":{"message":"enter"},"target":"test","span":{"name":"my_function"}}"#;
        let entries = parser.parse(content);
        
        assert_eq!(entries.len(), 1);
        let entry = &entries[0];
        assert_eq!(entry.level, "INFO");
        assert_eq!(entry.event_type, "span_enter");
        assert_eq!(entry.span_name.as_deref(), Some("my_function"));
    }

    #[test]
    fn test_parse_span_close() {
        let parser = LogParser::new();
        let content = r#"{"timestamp":"2024-01-01T00:00:00.000000Z","level":"INFO","fields":{"message":"close"},"target":"test","span":{"name":"my_function"}}"#;
        let entries = parser.parse(content);
        
        assert_eq!(entries.len(), 1);
        let entry = &entries[0];
        assert_eq!(entry.level, "INFO");
        assert_eq!(entry.event_type, "span_exit");
        assert_eq!(entry.span_name.as_deref(), Some("my_function"));
    }

    #[test]
    fn test_calculate_depth() {
        let parser = LogParser::new();
        // Test depth from spans array
        let entry1 = r#"{"level":"INFO","fields":{"message":"test"},"spans":[]}"#;
        let entry2 = r#"{"level":"INFO","fields":{"message":"test"},"spans":[{"name":"a"}]}"#;
        let entry3 = r#"{"level":"INFO","fields":{"message":"test"},"spans":[{"name":"a"},{"name":"b"}]}"#;
        
        let entries = parser.parse(&format!("{}\n{}\n{}", entry1, entry2, entry3));
        assert_eq!(entries[0].depth, 0);
        assert_eq!(entries[1].depth, 1);
        assert_eq!(entries[2].depth, 2);
    }
}
