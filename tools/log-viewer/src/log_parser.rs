//! Log file parser for tracing output
//!
//! Parses the compact format logs generated by context-trace's tracing_utils.

use regex::Regex;
use serde::Serialize;
use std::collections::HashMap;

/// A parsed log entry
#[derive(Debug, Clone, Serialize)]
pub struct LogEntry {
    /// Line number in the original file
    pub line_number: usize,
    /// Log level (TRACE, DEBUG, INFO, WARN, ERROR)
    pub level: String,
    /// Timestamp string
    pub timestamp: Option<String>,
    /// The log message
    pub message: String,
    /// Event type (event, span_enter, span_exit)
    pub event_type: String,
    /// Span name (if this is a span event)
    pub span_name: Option<String>,
    /// Indentation depth (number of parent spans)
    pub depth: usize,
    /// Additional fields
    pub fields: HashMap<String, String>,
    /// Source file location
    pub file: Option<String>,
    /// Source line number
    pub source_line: Option<u32>,
    /// Raw line content
    pub raw: String,
}

/// Parser for log files
pub struct LogParser {
    // Regex patterns for parsing
    level_pattern: Regex,
    timestamp_pattern: Regex,
    span_enter_pattern: Regex,
    span_close_pattern: Regex,
    event_pattern: Regex,
    field_pattern: Regex,
    location_pattern: Regex,
}

impl LogParser {
    pub fn new() -> Self {
        Self {
            // Match log levels
            level_pattern: Regex::new(r"\b(TRACE|DEBUG|INFO|WARN|ERROR)\b").unwrap(),
            // Match timestamps like "0.001s", "+0.001s", "0ms", "123ms"
            timestamp_pattern: Regex::new(r"\+?(\d+(?:\.\d+)?)(m?s)\b").unwrap(),
            // Match span enter: "SPAN ENTERED: function_name"
            span_enter_pattern: Regex::new(r"SPAN ENTERED:\s*(\S+)").unwrap(),
            // Match span close: "SPAN CLOSED: function_name (took 0.001s)"
            span_close_pattern: Regex::new(r"SPAN CLOSED:\s*(\S+)(?:\s*\(took\s*([\d.]+)s\))?").unwrap(),
            // Match regular events: "EVENT: message"
            event_pattern: Regex::new(r"EVENT:\s*(.*)").unwrap(),
            // Match fields: "field=value" or "field=\"quoted value\""
            field_pattern: Regex::new(r#"(\w+)\s*=\s*(?:"([^"]+)"|(\S+))"#).unwrap(),
            // Match source location: "at path/to/file.rs:123" or "at path\to\file.rs:123"
            location_pattern: Regex::new(r"at\s+([^\s:]+):(\d+)").unwrap(),
        }
    }

    /// Parse log content into structured entries
    pub fn parse(&self, content: &str) -> Vec<LogEntry> {
        let mut entries = Vec::new();
        let mut current_entry: Option<LogEntry> = None;
        
        for (line_number, line) in content.lines().enumerate() {
            let line_num = line_number + 1;
            
            // Check if this is a new log entry or continuation
            if let Some(level) = self.extract_level(line) {
                // Save previous entry
                if let Some(entry) = current_entry.take() {
                    entries.push(entry);
                }
                
                // Start new entry
                current_entry = Some(self.parse_line(line_num, &level, line));
            } else if let Some(ref mut entry) = current_entry {
                // This is a continuation line (e.g., file location or additional fields)
                self.parse_continuation(entry, line);
            }
        }
        
        // Don't forget the last entry
        if let Some(entry) = current_entry {
            entries.push(entry);
        }
        
        entries
    }

    fn extract_level(&self, line: &str) -> Option<String> {
        // Only match level at the start of an entry (after indentation)
        let trimmed = line.trim_start_matches(|c| c == '│' || c == ' ' || c == '┬' || c == '└' || c == '─' || c == '●');
        self.level_pattern.find(trimmed).and_then(|m| {
            // Make sure it's near the start
            if m.start() < 20 {
                Some(m.as_str().to_string())
            } else {
                None
            }
        })
    }

    fn parse_line(&self, line_number: usize, level: &str, line: &str) -> LogEntry {
        let depth = self.calculate_depth(line);
        let timestamp = self.timestamp_pattern
            .captures(line)
            .map(|c| c.get(1).unwrap().as_str().to_string());
        
        let (event_type, span_name, message) = if let Some(caps) = self.span_enter_pattern.captures(line) {
            let name = caps.get(1).map(|m| m.as_str().to_string());
            ("span_enter".to_string(), name.clone(), format!("SPAN ENTERED: {}", name.unwrap_or_default()))
        } else if let Some(caps) = self.span_close_pattern.captures(line) {
            let name = caps.get(1).map(|m| m.as_str().to_string());
            let duration = caps.get(2).map(|m| m.as_str().to_string());
            let msg = if let Some(ref d) = duration {
                format!("SPAN CLOSED: {} (took {}s)", name.as_deref().unwrap_or(""), d)
            } else {
                format!("SPAN CLOSED: {}", name.as_deref().unwrap_or(""))
            };
            ("span_exit".to_string(), name, msg)
        } else if let Some(caps) = self.event_pattern.captures(line) {
            let msg = caps.get(1).map(|m| m.as_str().to_string()).unwrap_or_default();
            ("event".to_string(), None, msg)
        } else {
            // Fallback: use the whole line as message
            ("unknown".to_string(), None, line.to_string())
        };
        
        // Extract fields
        let mut fields = HashMap::new();
        for caps in self.field_pattern.captures_iter(line) {
            let key = caps.get(1).unwrap().as_str().to_string();
            let value = caps.get(2)
                .or(caps.get(3))
                .map(|m| m.as_str().to_string())
                .unwrap_or_default();
            // Skip some known non-field patterns
            if !["SPAN", "EVENT", "took", "at"].contains(&key.as_str()) {
                fields.insert(key, value);
            }
        }
        
        LogEntry {
            line_number,
            level: level.to_string(),
            timestamp,
            message,
            event_type,
            span_name,
            depth,
            fields,
            file: None,
            source_line: None,
            raw: line.to_string(),
        }
    }

    fn parse_continuation(&self, entry: &mut LogEntry, line: &str) {
        // Check for source location
        if let Some(caps) = self.location_pattern.captures(line) {
            entry.file = caps.get(1).map(|m| m.as_str().to_string());
            entry.source_line = caps.get(2).and_then(|m| m.as_str().parse().ok());
        }
        
        // Check for additional fields
        for caps in self.field_pattern.captures_iter(line) {
            let key = caps.get(1).unwrap().as_str().to_string();
            let value = caps.get(2)
                .or(caps.get(3))
                .map(|m| m.as_str().to_string())
                .unwrap_or_default();
            if !["at"].contains(&key.as_str()) {
                entry.fields.insert(key, value);
            }
        }
        
        // Append to raw content
        entry.raw.push('\n');
        entry.raw.push_str(line);
    }

    fn calculate_depth(&self, line: &str) -> usize {
        // Count the visual gutters (│) to determine depth
        line.chars().take_while(|&c| c == '│' || c == ' ').filter(|&c| c == '│').count()
    }
}

impl Default for LogParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_event() {
        let parser = LogParser::new();
        let content = "● +0.001s  DEBUG  EVENT: Processing token\n    at src/main.rs:42";
        let entries = parser.parse(content);
        
        assert_eq!(entries.len(), 1);
        let entry = &entries[0];
        assert_eq!(entry.level, "DEBUG");
        assert_eq!(entry.event_type, "event");
        assert_eq!(entry.message, "Processing token");
        assert_eq!(entry.file.as_deref(), Some("src/main.rs"));
        assert_eq!(entry.source_line, Some(42));
    }

    #[test]
    fn test_parse_span_enter() {
        let parser = LogParser::new();
        let content = "┬─ +0.002s  INFO   SPAN ENTERED: my_function";
        let entries = parser.parse(content);
        
        assert_eq!(entries.len(), 1);
        let entry = &entries[0];
        assert_eq!(entry.level, "INFO");
        assert_eq!(entry.event_type, "span_enter");
        assert_eq!(entry.span_name.as_deref(), Some("my_function"));
    }

    #[test]
    fn test_parse_span_close() {
        let parser = LogParser::new();
        let content = "└─ +0.010s  INFO   SPAN CLOSED: my_function (took 0.008s)";
        let entries = parser.parse(content);
        
        assert_eq!(entries.len(), 1);
        let entry = &entries[0];
        assert_eq!(entry.level, "INFO");
        assert_eq!(entry.event_type, "span_exit");
        assert_eq!(entry.span_name.as_deref(), Some("my_function"));
    }

    #[test]
    fn test_calculate_depth() {
        let parser = LogParser::new();
        assert_eq!(parser.calculate_depth("● event"), 0);
        assert_eq!(parser.calculate_depth("│ ● event"), 1);
        assert_eq!(parser.calculate_depth("│ │ ● event"), 2);
    }
}
