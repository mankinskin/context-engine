---
tags: `#guide` `#testing` `#visualization` `#cross-language` `#log-viewer`
summary: How the search path visualization types are tested across Rust and TypeScript using shared JSON fixtures.
---

# Search Path Cross-Language Testing Guide

## Overview

The search path visualization system (`VizPathGraph`, `PathTransition`, etc.) is implemented in both Rust and TypeScript. A cross-language test pipeline ensures both implementations produce identical results from the same transition sequences.

**Workflow:**
1. Rust generates JSON fixture files containing transition sequences and expected `VizPathGraph` outputs
2. TypeScript reads those fixtures and verifies its reconstruction matches

## File Locations

| File | Purpose |
|------|---------|
| `crates/context-trace/src/graph/search_path.rs` | Rust types, `VizPathGraph::apply()`, and fixture generator |
| `tools/log-viewer/frontend/src/search-path/reconstruction.ts` | TypeScript mirror of `VizPathGraph` reconstruction |
| `tools/log-viewer/frontend/src/search-path/reconstruction.test.ts` | Vitest tests (fixtures + edge cases) |
| `tools/log-viewer/frontend/src/search-path/test-fixtures.json` | Generated fixtures (do not edit manually) |
| `tools/log-viewer/frontend/src/types/generated/` | ts-rs generated TypeScript types |

## Running Tests

### Regenerate fixtures (after Rust type changes):

```bash
cargo test -p context-trace generate_cross_language_fixtures -- --nocapture
```

This writes `test-fixtures.json` to the frontend's `search-path/` directory.

### Run TypeScript tests:

```bash
cd tools/log-viewer/frontend
npm test          # single run
npm run test:watch  # watch mode
```

### Full pipeline:

```bash
cargo test -p context-trace generate_cross_language_fixtures -- --nocapture
cd tools/log-viewer/frontend && npm test
```

## How It Works

### Rust Side (`search_path.rs`)

The `generate_cross_language_fixtures` test builds a `Vec<TestFixture>`:

```rust
struct TestFixture {
    name: String,
    transitions: Vec<PathTransition>,
    expected: VizPathGraph,
}
```

Each fixture defines a transition sequence and the expected `VizPathGraph` after applying all transitions via `VizPathGraph::from_transitions()`. The test serializes this to JSON using serde (snake_case fields, `"kind"` discriminant for enums).

### TypeScript Side (`reconstruction.test.ts`)

The test file:
1. Reads `test-fixtures.json` at import time
2. Creates one test per fixture: calls `fromTransitions(fixture.transitions)` and asserts `deepEqual` against `fixture.expected`
3. Also includes standalone edge-case tests for invalid transition sequences (e.g., `PushParent` before `SetStartNode`)

### Type Generation

TypeScript types are generated by `ts-rs` from Rust derive macros:

```rust
#[derive(Serialize, Deserialize, TS)]
#[ts(export)]
pub struct VizPathGraph { ... }
```

Run `cargo test -p context-trace export_bindings` to regenerate the `.ts` type files in `tools/log-viewer/frontend/src/types/generated/`.

## Fixture Coverage

Current fixtures cover 7 scenarios:

| Fixture | Transitions | Tests |
|---------|------------|-------|
| `simple_start_only` | SetStartNode | Minimal path |
| `start_with_parents` | SetStartNode → PushParent ×2 | Start path growth |
| `full_search_path` | Start → Parents → Root → Child → Match → Done | Complete successful search |
| `mismatch_path` | Start → Root → Child → Mismatch → Done | Failed match |
| `backtrack_and_retry` | Start → Root → Child → Mismatch → Pop → Push → Match → Done | Backtracking |
| `replace_child` | Start → Root → Child → Replace → Match → Done | In-place child swap |
| `deep_nested_path` | Start → Parent ×2 → Root → Child ×3 → Match → Done | Deep nesting |

## Adding New Fixtures

1. Add a new `TestFixture` entry in `build_fixtures()` in `search_path.rs`
2. Run `cargo test -p context-trace generate_cross_language_fixtures`
3. Run `npm test` in the frontend — the new fixture is picked up automatically

## When to Regenerate

Regenerate fixtures whenever:
- `PathTransition` variants change (new/renamed/removed)
- `VizPathGraph` fields change
- `VizPathGraph::apply()` logic changes
- Serde serialization format changes

If you change the Rust types without regenerating, the TypeScript tests will fail with either deserialization errors or mismatched expected values.
